"""
Программа реализует алгоритм Флойда-Уоршелла для поиска минимального пути между всеми парами
различных вершин в полном взвешенном ориентированном графе. Граф задается матрицей смежности,
где на диагонали должны быть нули (расстояние от вершины до самой себя).

Функциональное назначение:
1. Чтение входных данных из файла INPUT.TXT
2. Проверка корректности входных данных
3. Применение алгоритма Флойда-Уоршелла для поиска кратчайших путей между всеми парами вершин
4. Проверка наличия циклов отрицательного веса
5. Поиск минимального пути среди всех пар различных вершин
6. Запись результата в файл OUTPUT.TXT

Особенности реализации:
- Обработка возможных ошибок ввода/вывода
- Проверка корректности структуры входных данных
- Поддержка графов размером от 3 до 50 вершин
- Детектирование циклов отрицательного веса
"""

import sys
from typing import List

# Константа для представления бесконечности (хотя в полном графе она не нужна,
# но полезна для общего случая и инициализации минимума)
INF = float("inf")


# Решение задачи поиска минимального пути между всеми парами различных вершин
def solve() -> None:
    """
    Description:
    ---------------
        Основная функция программы, реализующая алгоритм Флойда-Уоршелла.
        Читает входные данные из файла, обрабатывает граф, находит минимальный путь
        между всеми парами вершин и записывает результат в выходной файл.

    Raises:
    ---------------
        SystemExit: В случае ошибок ввода/вывода или некорректных данных
    """
    # --- Чтение входных данных ---
    try:
        with open("INPUT.TXT", "r") as f_in:
            n = int(f_in.readline())
            # Инициализируем матрицу расстояний исходными весами ребер
            dist: List[List[int]] = []
            for i in range(n):
                row = list(map(int, f_in.readline().split()))
                # Проверяем корректность размера строки матрицы
                if len(row) != n:
                    raise ValueError(f"Строка {i + 1} матрицы имеет неверную длину.")
                # Проверяем диагональный элемент
                if row[i] != 0 and n > 0:  # Добавим проверку n>0 для избежания IndexError
                    print(
                        f"Предупреждение: Диагональный элемент dist[{i}][{i}] не равен 0."
                    )
                dist.append(row)

            # Проверка корректности N
            if not (3 <= n <= 50):
                raise ValueError(
                    f"Количество вершин N={n} вне допустимого диапазона [3, 50]."
                )

    except FileNotFoundError:
        print("Ошибка: Файл INPUT.TXT не найден.")
        sys.exit(1)  # Выход, так как без входных данных не продолжить
    except ValueError as ve:
        print(f"Ошибка в формате входных данных: {ve}")
        sys.exit(1)
    except Exception as e:
        print(f"Непредвиденная ошибка при чтении входных данных: {e}")
        sys.exit(1)

    # --- Алгоритм Флойда-Уоршелла ---
    # dist[i][j] хранит кратчайшее расстояние от i до j
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # Стандартная релаксация: проверяем, не короче ли путь i -> k -> j
                # чем текущий известный путь i -> j
                if dist[i][k] != INF and dist[k][j] != INF:
                    new_dist = dist[i][k] + dist[k][j]
                    if new_dist < dist[i][j]:
                        dist[i][j] = new_dist

    # --- Проверка на наличие циклов отрицательного веса ---
    has_negative_cycle = False
    for i in range(n):
        # Если после всех релаксаций путь из вершины в саму себя стал отрицательным,
        # значит, существует цикл отрицательного веса, проходящий через эту вершину.
        if dist[i][i] < 0:
            has_negative_cycle = True
            break

    # --- Вычисление результата ---
    result = -1
    if has_negative_cycle:
        # Если есть отрицательный цикл, минимум не существует
        result = -1
    else:
        # Ищем минимальный путь среди всех пар РАЗЛИЧНЫХ вершин
        min_path = INF
        found_path = False  # Флаг, что найден хотя бы один путь
        for i in range(n):
            for j in range(n):
                if i != j:
                    # Учитываем только пути между различными вершинами
                    if dist[i][j] < min_path:
                        min_path = dist[i][j]
                        found_path = True

        # Если хотя бы один путь был найден
        if found_path:
            result = min_path

    # --- Запись результата в файл ---
    try:
        with open("OUTPUT.TXT", "w") as f_out:
            f_out.write(str(result) + "\n")
    except IOError as e:
        print(f"Ошибка при записи в файл OUTPUT.TXT: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Непредвиденная ошибка при записи результата: {e}")
        sys.exit(1)


# Запуск решения
if __name__ == "__main__":
    solve()